<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>TcpClient2: A C-Language Library for Writing Generic TCP Client Applications</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>A C-Language Library for Writing Generic TCP Client Applications </h1><h3 class="version">Version 1.00 </h3><p>A library for writing simple TCP client applications, written in the C-language with an object oriented approach, using the Berkeley sockets interface, and intended to be cross-platform. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>A <b> generic client </b> written with this library is a simple TCP client application created following a specific pattern that is built around three concepts: <b> state</b>, <b> event</b> and <b> command</b>. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p><b> State </b> is one of these <br/>
   (1) <b> CONNECTED_IDLE </b> <br/>
   (2) <b> NOT_CONNECTED </b>. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p><b> Command </b> is one of these: <br/>
   (1) <b>CONNECT</b> <br/>
   (2) <b>SEND</b> <br/>
   (3) <b>RECV</b> <br/>
   (4) <b>CLOSE</b>. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p><b>Event</b> is one of these: <br/>
   (1) <b>CONNECTION_CREATED</b> <br/>
   (2) <b>CONNECTION_DESTROYED</b> <br/>
   (3) <b>CONNECT_ERROR</b> <br/>
   (4) <b>RECV_COMPLETE</b> <br/>
   (5) <b>RECV_TIMEOUT</b> <br/>
   (6) <b>SEND_COMPLETE</b>. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>There are also two other entities involved: an instance of the <a class="el" href="structGenericClient.html" title="GenericClient class.">GenericClient</a> class, provided by the library, and the <b>application code</b> written by the user of the library. The <a class="el" href="structGenericClient.html" title="GenericClient class.">GenericClient</a> class is informally derived from the <a class="el" href="classClient.html" title="Client class.">Client</a> class, which provides the basic methods for writing client applications. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>The general flow of control in an application written with this library is like this: <br/>
   (1) the <b> application code </b> passes up a <b> command</b> to the <a class="el" href="structGenericClient.html" title="GenericClient class.">GenericClient</a> instance, <br/>
   (2) which processes the received <b> command</b> and passes down an <b>event</b> to the <b> application code</b>; <br/>
   (3) the <b> application code </b> then processes the <b> event </b> received from the <a class="el" href="structGenericClient.html" title="GenericClient class.">GenericClient</a> instance, and the cycle repeats again. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>The <a class="el" href="structGenericClient.html" title="GenericClient class.">GenericClient</a> instance is driven by a state machine, which is described below in pseudo-code:</p>
<div class="fragment"><pre class="fragment">    1. <span class="keywordflow">if</span> state is NOT_CONNECTED

          <span class="comment">// only accepts the CONNECT command</span>
          <span class="keywordflow">do</span> connect

          <span class="keywordflow">if</span> result is OK
             <span class="keyword">set</span> state to CONNECTED_IDLE
             <span class="keywordflow">return</span> <span class="keyword">event</span> CONNECTION_CREATED
          <span class="keywordflow">else</span>
             <span class="comment">// remains in the state NOT_CONNECTED</span>
             <span class="keywordflow">return</span> <span class="keyword">event</span> CONNECT_ERROR

    2. <span class="keywordflow">if</span> state is CONNECTED_IDLE

          2.1 <span class="keywordflow">if</span> command is SEND
              <span class="keywordflow">do</span> send
              <span class="keywordflow">if</span> result is OK
                 <span class="comment">// remains in the state CONNECTED_IDLE</span>
                 <span class="keywordflow">return</span> <span class="keyword">event</span> SEND_COMPLETE
              <span class="keywordflow">else</span>
                <span class="keyword">set</span> state to NOT_CONNECTED
                <span class="keywordflow">return</span> <span class="keyword">event</span> CONNECTION_DESTROYED

          2.2 <span class="keywordflow">if</span> command is RECV
              <span class="keywordflow">do</span> recv
              <span class="keywordflow">if</span> result is OK
                 <span class="comment">// remains in the state CONNECTED_IDLE</span>
                 <span class="keywordflow">return</span> <span class="keyword">event</span> RECV_COMPLETE
              <span class="keywordflow">else</span> <span class="keywordflow">if</span> occurred TIMEOUT
                 <span class="comment">// remains in the state CONNECTED_IDLE</span>
                 <span class="keywordflow">return</span> <span class="keyword">event</span> RECV_TIMEOUT
              <span class="keywordflow">else</span> <span class="comment">// error</span>
                 <span class="keyword">set</span> state to NOT_CONNECTED
                 <span class="keywordflow">return</span> <span class="keyword">event</span> CONNECTION_DESTROYED

          2.3 <span class="keywordflow">if</span> command is CLOSE
              <span class="keywordflow">do</span> close
              <span class="keyword">set</span> state to NOT_CONNECTED
              <span class="keywordflow">return</span> <span class="keyword">event</span> CONNECTION_DESTROYED
</pre></div><p>The <b> application code</b> doesn't have to be concerned with how the <a class="el" href="structGenericClient.html" title="GenericClient class.">GenericClient</a> instance works; its only concern is how to handle the events it receives from the <a class="el" href="structGenericClient.html" title="GenericClient class.">GenericClient</a> instance. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>The pseudo-code for the <b>application code</b> is open, but generally will be like the following:</p>
<div class="fragment"><pre class="fragment">

    1. if event is CONNECTION_CREATED
          prepare message to send to the server
          pass the command SEND to the library

    2. if event is SEND_COMPLETE
          update whatever controls needed by the application
          pass the command RECV to the library

    3. if event is RECV_COMPLETE
          process reply received from the server
          prepare another message to send to the server
          pass the command SEND to the library

    4. if event is RECV_TIMEOUT (*** optional ***)
          do whatever the application needs in case of timeout
          if business rules says try again
             prepare another message to send to the server
             pass the command SEND to the library
          else
             pass the command CLOSE to the library

    5. if event is CONNECTION_DESTROYED
          // can be the result of SEND, RECV or CLOSE commands
          // (most errors will automatically destroy the connection)
          do whatever cleanup the application needs
          pass the command CONNECT to the library

    6. if event is CONNECT_ERROR
          do whatever the application needs in this case
          if business rules says try again
             pass the command CONNECT to the library
          else
             end application

    </pre></div><p>Using the pattern described above, writing simple TCP client applications is a snap, because nowhere the TCP/IP networking code is seen. In practice, only the application code needs to be written. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>The goal here is not writing production-grade applications, but small utilities for testing scenarios, for prototyping new functionalities, for finding application bugs in servers, etc. In these cases, speed of development is of paramount importance, because often the programs created are discardable, throwaway utilities, with limited scope and functionality, which do no justify spending too much time in their development. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>The C code that implements the pseudo-code above is something like this: </p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">switch</span> (<a class="code" href="GenericClient_8h.html#a796987c44cef7aa163f189b827610fac" title="see Client::genCli_waitEvent">genCli_waitEvent</a>())
    {
       <span class="keywordflow">case</span> <a class="code" href="GenericClient_8h.html#a0be5647fd0926a22950d6106991586bba6e08f7a76bef434b2172b6fb7346e7cc">CLI_EVT_CONNECTION_CREATED</a>:
          prepareFirstMessage();
          <a class="code" href="GenericClient_8h.html#a23da57feb26683c14ffedd0d649a22d1" title="see Client::genCli_send">genCli_send</a>();
          <span class="keywordflow">break</span>;

       <span class="keywordflow">case</span> <a class="code" href="GenericClient_8h.html#a0be5647fd0926a22950d6106991586bbaa2463a1940371976699eec52b492c430">CLI_EVT_RECV_COMPLETE</a>:
          processServerReply();
          prepareAnotherMessage();
          <a class="code" href="GenericClient_8h.html#a23da57feb26683c14ffedd0d649a22d1" title="see Client::genCli_send">genCli_send</a>();
          <span class="keywordflow">break</span>;

       <span class="keywordflow">case</span> <a class="code" href="GenericClient_8h.html#a0be5647fd0926a22950d6106991586bba1b7016c33830495cb9d1564bbab8b95d">CLI_EVT_SEND_COMPLETE</a>:
          <a class="code" href="GenericClient_8h.html#ada17c034d6ef0a119ce68df7dda02313" title="see Client::genCli_recv">genCli_recv</a>();
          <span class="keywordflow">break</span>;

       <span class="keywordflow">case</span> <a class="code" href="GenericClient_8h.html#a0be5647fd0926a22950d6106991586bbab397a1ba4584b4b35355eceb5f2c4b23">CLI_EVT_RECV_TIMEOUT</a>:
          prepareAnotherMessage();
          <a class="code" href="GenericClient_8h.html#a23da57feb26683c14ffedd0d649a22d1" title="see Client::genCli_send">genCli_send</a>();
          <span class="keywordflow">break</span>;

       <span class="keywordflow">case</span> <a class="code" href="GenericClient_8h.html#a0be5647fd0926a22950d6106991586bbaabb344ce999356eb156548c698e2fe5e">CLI_EVT_CONNECT_ERROR</a>:
          printConnectionError();
          <a class="code" href="Client_8h.html#af4dc9846f2c4ccc993e48cbe6bba7ed1" title="common sleep function">client_sleep</a>(5);
          <a class="code" href="GenericClient_8h.html#a6878849f6f316f7166da090005d8a7f0" title="see Client::genCli_connect">genCli_connect</a>();
          <span class="keywordflow">break</span>;

       <span class="keywordflow">case</span> <a class="code" href="GenericClient_8h.html#a0be5647fd0926a22950d6106991586bba727593ffcb45fcdd349d6c239b73c170">CLI_EVT_CONNECTION_DESTROYED</a>:
          printOperationError();
          <a class="code" href="GenericClient_8h.html#a6878849f6f316f7166da090005d8a7f0" title="see Client::genCli_connect">genCli_connect</a>();
          <span class="keywordflow">break</span>;

       <span class="keywordflow">default</span>:
          printf(<span class="stringliteral">&quot;*invalid event %d\n&quot;</span>, <a class="code" href="GenericClient_8h.html#a789e3f5fa2a8c3f7f2970bbdbbdae23b" title="see Client::genCli_event">genCli_event</a>());
          abort();
          <span class="keywordflow">break</span>;
    } <span class="comment">// switch</span>
</pre></div><p>Please refer to the <b>gen_client_1</b> example project for more details. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>The library also provides additional funcionality, presented by the <a class="el" href="classClient.html" title="Client class.">Client</a> class but in fact implemented by other classes (the <a class="el" href="classClient.html" title="Client class.">Client</a> class here acting as a façade). </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>The most important of the additional functionality is related to the <a class="el" href="structMessage.html" title="Message data structure.">Message</a> class. It provides an encapsulation for the buffers used when exchanging messages between client and server, and also provides the framing that delimits messages on the wire. Please see the documentation for the <a class="el" href="structMessage.html" title="Message data structure.">Message</a> class, for the <a class="el" href="classClient.html" title="Client class.">Client</a> class, and the <b>gen_client_1</b> example that is shipped with this project. For the record, the more important methods provided by the <a class="el" href="structMessage.html" title="Message data structure.">Message</a> class for the use of applications are (encapsulated by the <a class="el" href="classClient.html" title="Client class.">Client</a> class): <a class="el" href="Client_8h.html#ad61da6df60fa6b006c2309d43af4df7a">client_messageBuffer </a>, <a class="el" href="Client_8h.html#a52d2c5b2a47407540c43fae22a66f433">client_messageSize </a>, and <a class="el" href="Client_8h.html#a15fe6b6088b2a1f43bfbce6210ebf63a">client_setMessageSize </a>. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>There is also a <a class="el" href="classLog.html" title="Log class.">Log</a> class, that is used internally by the library but can also be used by applications. Its main methods are (again, encapsulated by the <a class="el" href="classClient.html" title="Client class.">Client</a> class): <a class="el" href="Client_8h.html#a8aeb64676bc421cf8b0c6620bcef3a06">client_logInfo </a>, <a class="el" href="Client_8h.html#adc41df6a7ae9723e3cfea5d8ff52afbd">client_logWarn </a>, <a class="el" href="Client_8h.html#a8645c6bb89cc3ccb4ef8ceb29ef2e49c">client_logDebug </a>, <a class="el" href="Client_8h.html#aae9f973b1b46e3bb8527f5576fa358cd">client_logTrace </a>, <a class="el" href="Client_8h.html#ac15aef834c7f98f36efcda6ad8d39f1d">client_logError </a> and <a class="el" href="Client_8h.html#a5e3e9256d16a7ec3dc02b06dabc21938">client_logFatal </a>. </p>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<p>There are some other classes used internally by the library, that may or may not be useful when writing the client applications: <a class="el" href="classMutex.html" title="Mutex class.">Mutex</a>, <a class="el" href="classThread.html" title="Thread class.">Thread</a>, <a class="el" href="classTime.html" title="Time formatting class.">Time</a> and <a class="el" href="structTimeout.html" title="Structure representing timeout.">Timeout</a>.</p>
<p>This library is written to inter-operate with servers written using the library described in this <a href="http://www.codeproject.com/KB/IP/TCPServerFramework.aspx">article</a>. Specifically, the <b>gen_client_1</b> example shipped with this project works with the <b> server_2 </b> and <b> server_3 </b> examples shipped with the article above.</p>
<p>To adapt the library to work with other servers it's very likely that the <a class="el" href="structMessage.html" title="Message data structure.">Message</a> structure declared in the <a class="el" href="MessageImpl_8h.html" title="Private interface for class Message.">MessageImpl.h</a> file will have to be changed. Specifically, refer to the on-the-wire format of the messages exchanged between the client and the server. </p>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Sat May 8 16:16:35 2010 for TcpClient2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
